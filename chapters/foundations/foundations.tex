In this chapter I will provide and explain the concepts and terms that are used throughout this thesis. 
I will cover the definitions of a GUI and GUI-Model as well as the basic terminology of a task tree, followed by 
 information on alignment algorithms and substitution matrixes.
The last section describes the method for task tree generation by Harms et al.\cite{harms2013}


\section{GUI and GUI-Model}
\label{sec:foundationguiandguimodel}
GUI is short for graphical user interface which is an interface that is used to issue commands to a computer by means of a device such as a mouse that manipulates and activates onscreen images.\cite{Dictionary.com2014}

TODO: GUI Model

\section{Task Tree Terminology}
\label{sec:foundationtasktreeterminology}
Harms et al.\cite{harms2013} has created a set of definitions and the respective vocabulary that help dealing with task trees.
I will adopt his definitions and summarize them in this section.
To understand tasks and task trees we have to look at how users interact with software. 

Users perfoming actions like clicking or typing trigger so called events. Those events consist of a type and a target. 
The type describes the type of the action that triggered that event (e.g. onclick), the target describes the element in the GUI the event occurred on.
The events a user creates can be traced which is the basic step to gather data that is needed to generate task trees. 
A trace is a list of events in the order they occurred. Figure \ref{fig:trace} shows an example of such a trace. 
All events in this list and their corresponding actions represent the users intention to achieve a goal while using the software e.g. buying a book 
in an online shop. From now on this goal is named task. This task can consist of several subtasks such as logging in or putting a book into the basket.
Each subtask itself can again contain futher subtasks. From figure \ref{fig:booktree} one can see that this results in a tree structure, a so called trask tree.

\begin{figure}
	\label{fig:booktree}
	\caption{Simplified and not complete visit of an online book shop as a task tree}
\end{figure}

A task tree consists of three different kinds of nodes:
\begin{itemize} 
	\item Root node: Represents the overall task which contains all subtasks, the user wants to "reach" this node by his actions/his input. 
		In figure \ref{fig:booktree} the overall task is to buy books at an online shop.
	\item Intermediate nodes: Are subtasks which are steps towards the overall task. In figure \ref{fig:booktree} the intermediate nodes are login, search and order.
	\item Leaf nodes: Actions (e.g. click, scroll, textinput) which cause an event (e.g. \textit{onclick} (click) or \textit{onchange} (textinput). The tasks at this level are called event tasks.
		The event tasks of \ref{fig:booktree} are 
\end{itemize}

	%\item Where should i write about the difference between tasks and taskinstances? 	
	%\item temporal relationship: the order of the executed actions is important, so it is saved in the task tree
	%\item different ways of temporal relationship used by harms: 
	\begin{itemize}
		\item sequences: children executed in specific order
		\item iteration: only one child, executed zero or more times
		\item selection: only one of the children is executed
		\item optional:  only one child, executed once or not
	\end{itemize}	
	
	\begin{figure}
		%\tikzstyle{every node}=[draw=black,thick,anchor=west]   
		\tikzstyle{every node}=[rectangle, draw=none, rounded corners=1mm,
		        text centered, anchor=west, text=black, fill=blue!25]
		%\tikzstyle{selected}=[draw=red,fill=red!30]
		%\tikzstyle{optional}=[dashed,fill=gray!50]
		
		\begin{tikzpicture}[%
		  grow via three points={one child at (0.5,-0.7) and
		  two children at (0.5,-0.7) and (0.5,-1.4)},
		  edge from parent path={(\tikzparentnode.south) |- (\tikzchildnode.west)}]
		  \node {Sequence}
		    child { node {Iteration}       
		      child { node {Selection}
		        child { node {Sequence}
		          child { node {Click        on   Textfield}}
		          child { node {Enter user name    into Textfield}}
		      child [missing] {}
		          child [missing] {}
		    }
		        child [missing] {}
		    child [missing] {}
		        child { node {Sequence}
		          child { node {Click        on   Textfield "password"}}
		          child { node {Enter password  into Textfield "password"}}
		        }
		      }
		    }
		    child [missing] {}
		    child [missing] {}
		    child [missing] {}
		    child [missing] {}
		    child [missing] {}
		    child [missing] {}
		    child [missing] {}
		    child { node {Click        on   Button "login"}};
		%    child [missing] {}               
		%    child [missing] {}               
		%    child [missing] {}
		\end{tikzpicture}
		\label{fig:exampletasktree}
		\caption{An example for a task tree with temporal relations\cite{harms2013}.}
	\end{figure}
\section{Alignments}
What are alignments? 
\begin{itemize}
	\item String algorithm often used in bioinformatics 
	\item arranging sequences of DNA, RNA, Peptids to identify meaningful regions.
	\item Meaningful regions are conserved, little mutations in sequences
	\item Representation: Sequences in rows, aligned 
	\item Minimal example of two aligned sequences here (with gaps though)
	\item 2 Main categories: global and local alignments 
	\item global: find best alignment end to end: better for very similar sequences
	\item local: find best alignment of subsequence: better for finding conserved regions of not so similar sequences
	\item Basic Algorithms: NeedleMan Wunsch(global), Smith Waterman(local) 
\end{itemize} 


\section{Substitution Matrixes}
\label{sec:foundationsubstitutionmatrix}
	\begin{itemize}
		\item Representation of how similar two elements in a sequence are. 
		\item Alignment algorithms use this information to arrange the two sequences 
		\item Usually symmetric matrices where each cell represents how good or bad it is to substitute element a with element b  
	\end{itemize}
	\paragraph{Biological background}
	In Biology popular matrices are generated from real DNA data (PAM, BLOSUM) (cite)


\section{State of the Art of Trace Based Task Tree Generation}
\begin{itemize}
	\item Procedure: start with leaf nodes to creat a task tree
 	\item for every event in a trace: create an event task instance
  	\item event tasks instances stored in recorded order

	\item Iteration detection:
	\begin{itemize} 
		\item identical tasks, which often repeat directly (e.g.: click on the same button a few times): Iteration
		\item generate a new task model of type iteration: iterated event task as single child
		\item replace every occured iteration of the event task with the iteration task node 
	\end{itemize}

	\item Sequence detection:
	\begin{itemize}
		\item task list scanned for identical subsequences
    		\item most occured and longest subsequence: propably a logical and useful subtask
		\item new task node type sequence generated
		\item every identical subsequence replaced with the new task node 
		\item if same length and count of subsequence: first subsequence will be replaced (always only one subsequence replaced!
    		\item minimal length of a subsequence: 2 actions/ event tasks
	\end{itemize}
	\item Repetition of Detections:
	\begin{itemize}
		\item iteration and sequence detection repeatet until there are no matches anymore
  		\item replaced sequences may already contain iterations/sequences 
		\item in the end: list with task trees and event tasks that does not fit in as an iteration or sequence
		\item Problem: some event tasks are used only once (e.g. login) or very seldom by one user
		\item solution: compare data of more users 
	\end{itemize}
\end{itemize}
