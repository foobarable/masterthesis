\section{Improving Task Tree Generation}
Summarize harms methdos downside and give an overview about how i generate a tasktree
Use this description of my algorithm as a guide through this chapter
\section{Task Tree Generation}
	\begin{itemize}
		\item Similar to pharms method
		\item Harmonization of user session
		\item Creation of Substitution matrix
		\item Main Loop:
		\begin{itemize}
			\item Iteration detection (no changes made)
			\item Optional: Updating the substitution Matrix
			\item Sequence detection
		\end{itemize}
		\item Repetition of Iteration Detection and Sequence Detection (Main Loop)
	\end{itemize}

\section{Harmonization}
Describe Event Task Instance Harmonization
\begin{itemize}
	\item For each Session, For each EventTaskInstance in Session:
	\item Remember Tasks that occured already
	\item Unify Task of a new EventTaskInstance if it has a task that already occured
	\item Result is also a List of all unique Tasks (needed for substitution matrix generation)
\end{itemize}

\section{Substitution Matrix}
	\begin{itemize}
		\item Representation of how similar two elements in a sequence are. 
		\item Alignment algorithms use this information to arrange the two sequences 
		\item Usually symmetric matrices where each cell represents how good or bad it is to substitute element a with element b  
	\end{itemize}
	\paragraph{Biological background}
	In Biology popular matrices are generated from real DNA data (PAM, BLOSUM) (cite)
	\paragraph{Objectdistance Substitution Matrix}
	\begin{itemize}
		\item The substitution used here is based on the distance of elements in the GUI model of events
		\item What is a GUI Model? Small example and description here
		\item Algorithm of creation: For Every unique EventTask: substition score of (a,b) = -1*distanceInGuiModel(a,b)+k, with k the maximum value the score can take.
		\item The k Parameter is dependent on the underlying gui model. A large k should be chosen vor very deeply, nested gui-models, whereas for flat gui models a smaller k seems better. 
		\item Another Problem: Size of substitution matrix can grow large for a huge number of EventTasks. Memory Usage: O(n*(n+1)/2) 
		\item For non EventTasks (which don't have a GUI model) the following procedure of distance calculation is proposed:
		\item distance = The mean distance between all children of each Task, that are EventTasks
		\item This step is implemented, but not used due to problem size. Thus, all non-EventTask-Tasks have a score of 0 to any other Task/EventTask
	\end{itemize}

\section{Iteration Detection and Substitution Matrix update}
\begin{itemize}
	\item Iteration Detection does not differ from harms method
	\item Optional: Substitution Matrix Update 
	\begin{itemize}
		\item Calculate distances from newly created tasks (either from iteration or sequence detection) to all the old unique tasks
		\item Add newly created tasks to the unique Tasks
		\item Reset newlycreated Tasks
		\item This step is currently skipped due to perfomance issues, details about this in the case study section
	\end{itemize}
\end{itemize}


\section{Sequence Detection}
\begin{itemize}
	\item Sequence Detection is separated in 3 steps
	\begin{itemize}
		\item Search for significant regions
		\item Model generation
		\item Replacement
	\end{itemize}
\end{itemize}
\subsection{Search for significant regions}		
\begin{itemize}
	\item For sequence detection a method called alignments is used
	\item It can be used for approximate string matching. 
	\item This is useful for this problem, because we also want to detect similar interactions of different users, not just equal interactions
	\item align each user session with any other user session (section alighments)  (if not mentioned, mention complexity of $O(n^2)$
\end{itemize}
\subsubsection{Alignments}
What are alignments? 
\begin{itemize}
	\item String algorithm often used in bioinformatics 
	\item arranging sequences of DNA, RNA, Peptids to identify meaningful regions.
	\item Meaningful regions are conserved, little mutations in sequences
	\item Representation: Sequences in rows, aligned 
	\item Minimal example of two aligned sequences here (with gaps though)
	\item 2 Main categories: global and local alignments 
	\item global: find best alignment end to end: better for very similar sequences
	\item local: find best alignment of subsequence: better for finding conserved regions of not so similar sequences
	\item Basic Algorithms: NeedleMan Wunsch(global), Smith Waterman(local) 
\end{itemize} 

\paragraph{Smith Waterman Algorithm For Repeated Matches}
\begin{itemize}
	\item Modified Version of the smith waterman algorithm
	\item Finds all local alignments of two sequences that reach a threshold score, not just the best
	\item Uses dynamic programming
	\item Exact method, not heuristic
	\item Two sequences: 
	\item y: pattern
	\item x: sequence in which we search all subsequences of y repeatedly
	\item Final aligment: x has matched and unmatched regions
	\item Uses matrix (dynamica programming matrix) where each cell stores the best score for aligning the elements at the position the cell represents
	\item Advantage: Possible alignments with less score do not need to be calculated recursively
	\item Score of a matched region: sum of all scores for each position minus the score threshold 
	\item first row has a different meaning than in basic Smith waterman (score of the last matched subsequence)
	\item Definitions:
	\item F is the dynamica programming matrix
	\item s is the substition matrix
	\item d is the gap penalty
\end{itemize}

\subparagraph{Intialization}:
	\begin{itemize}
		\item \[F(0,0) = 0\]
%		\item Fill first col with 0, 
	\end{itemize}

\subparagraph{Recursion}
	\begin{itemize}
		\item Build dynamic programmic matrix
		\item  \[F(i,0) = max \left\{ \begin{array}{lr}F(i-1,0)&\\F(i-1,j)-T& j=1,\dots,m\end{array}\right. \]
		\item  \[F(i,j) = max \left\{ \begin{array}{lr}F(i,0),\\F(i-1,j-1)+s(x_i,y_i),\\F(i-1,j)-d,\\F(i,j-1)-d\end{array}\right.\]
		\item Explain each choice we can take here
		\item Store every choice we took
	\end{itemize}
\subparagraph{Traceback}
Go back from the addition cell in the first row to first cell to get alignment

\subparagraph{Scoring}
Describe how each match is scored

\subparagraph{Match retrival}
	\begin{itemize}
		\item retrieve matches that reach a defined threshold from each alignment pair
		\item Due the nature of this algoritm, all matches that can be found have this minimal score
		\item A match consists of 2 sequences of numbers. 
		\item for each found match:
		\item Search match in all user sessions
		\item From the most to the least found match:
	\end{itemize}
\subsubsection{Model generation}
	\begin{itemize}
		\item Generate Model From Match is done the following way:
		\item For each position of the Match: 
		\item (remind, that each match has 2 Sequences of aligned numbers)
		\begin{itemize}
			\item If Both numbers are equal: The model at this position is the Task refered by this number
			\item If one sequence has a gap at this position: The other EventTask is inserted as an optional
			\item If both numbers differ a selection is inserted. Which kind of selection depends on what the following task is. We don't want to have 2 selections next to each other, instead, create one selection and add each sequence as a sequence
			\begin{itemize}
				\item If the next position also would be a selection, the selection has 2 sequences as a child. those sequences consists of the tasks of each sequence of the match until there is no more selection found 
				\item If the next position is something else we just have a single selection, just add the tasks of the match at this position as childs to the selection
				\item (This description here is really bad, will need some examples)
			\end{itemize}
		\end{itemize}
	\end{itemize}

\subsubsection{Replacement}
	\begin{itemize}
		\item Replace each model in the user sessions
	\end{itemize}

\subsection{Repetition}



